(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("LowCalStorage", [], factory);
	else if(typeof exports === 'object')
		exports["LowCalStorage"] = factory();
	else
		root["LowCalStorage"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(module) {var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/* Helper functions */

const cloneObject = obj => _extends({}, obj);

const getLowCalKeyMapDictionary = () => {
  const keyMapDictionaryRaw = localStorage.getItem('lowCalKeys');
  return !keyMapDictionaryRaw ? {} : JSON.parse(keyMapDictionaryRaw);
};

const getOwnKeys = obj => Object.keys(obj);

const generateCharacterString = (character, length) => new Array(length + 1).join(character);

const stringWithLastLetterReplaced = (inputString, newLastLetter) => inputString.substring(0, inputString.length - 1) + newLastLetter;

const getKeyFromValue = (obj, value) => getOwnKeys(obj).filter(k => obj[k] === value)[0];

const updateLowCalKeyMapDictionary = newDictionary => localStorage.setItem('lowCalKeys', JSON.stringify(newDictionary));

const isNullOrUndefined = value => value === null || value === undefined;

const setLowCalKey = (lowCalKey, fullFatKey) => {
  const keyMapDictionary = getLowCalKeyMapDictionary();
  keyMapDictionary[lowCalKey] = fullFatKey;
  updateLowCalKeyMapDictionary(keyMapDictionary);
};

/* End of Helper Functions */

const characters = 'a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,0,1,2,3,4,5,6,7,8,9'.split(',').sort();
const maxIndex = characters.length - 1;

const keySort = (key1, key2) => {
  const lengthOfKey1 = key1.length;
  const lengthOfKey2 = key2.length;
  if (lengthOfKey1 < lengthOfKey2) {
    return -1;
  } else if (lengthOfKey1 > lengthOfKey2) {
    return 1;
  } else if (key1 < key2) {
    return -1;
  } else if (key1 > key2) {
    return 1;
  } else {
    return 0;
  }
};

const getNextKey = () => {
  const keyMapDictionary = getLowCalKeyMapDictionary();
  const keysInOrder = getOwnKeys(keyMapDictionary).sort(keySort);

  if (keysInOrder.length === 0) {
    return characters[0];
  }

  const indexOfLastKey = keysInOrder.length - 1;
  const previousKey = keysInOrder[indexOfLastKey];
  const lengthOfPreviousKey = previousKey.length;
  const lastCharacterOfPreviousKey = previousKey[lengthOfPreviousKey - 1];
  const indexInCharactersArray = characters.indexOf(lastCharacterOfPreviousKey);

  if (indexInCharactersArray === maxIndex) {
    return generateCharacterString(lengthOfPreviousKey + 1, characters[0]);
  } else {
    const nextCharacter = characters[indexInCharactersArray + 1];
    return stringWithLastLetterReplaced(previousKey, nextCharacter);
  }
};

const getLowCalKeyIfAlreadyExists = key => {
  const keyMapDictionary = getLowCalKeyMapDictionary();
  return getKeyFromValue(keyMapDictionary, key);
};

const addKeyMapAndGetLowCalKey = key => {
  const existingKey = getLowCalKeyIfAlreadyExists(key);

  if (!isNullOrUndefined(existingKey)) {
    return existingKey;
  }

  const nextKey = getNextKey();
  setLowCalKey(nextKey, key);
  return nextKey;
};

const arrayConvertKeysToLowCal = array => {
  for (let i = 0; i < array.length; i++) {
    convertKeysToLowCal(array[i]);
  }
};

const objectConvertKeysToLowCal = obj => {
  for (let fullFatKey in obj) {
    if (!obj.hasOwnProperty(fullFatKey)) {
      continue;
    }

    const value = obj[fullFatKey]; // QQ does this need to be cloned?
    convertKeysToLowCal(value);
    const lowCalKey = addKeyMapAndGetLowCalKey(fullFatKey);

    delete obj[fullFatKey];
    obj[lowCalKey] = value;
  }
};

const convertKeysToLowCal = obj => {
  if (typeof obj !== 'object') {
    return;
  }

  if (Array.isArray(obj)) {
    arrayConvertKeysToLowCal(obj);
  } else {
    objectConvertKeysToLowCal(obj);
  }
};

const getOriginalKey = lowCalKey => {
  const keyMapDictionary = getLowCalKeyMapDictionary();
  return keyMapDictionary[lowCalKey] || lowCalKey;
};

const arrayConvertKeysFromLowCal = array => {
  for (let i = 0; i < array.length; i++) {
    convertKeysFromLowCal(array[i]);
  }
};

const objectConvertKeysFromLowCal = obj => {
  for (const lowCalKey in obj) {
    if (!obj.hasOwnProperty(lowCalKey)) {
      continue;
    }

    const value = obj[lowCalKey]; // QQ do I need to clone here?
    convertKeysFromLowCal(value);
    const fullFatKey = getOriginalKey(lowCalKey);

    delete obj[lowCalKey];
    obj[fullFatKey] = value;
  }
};

const convertKeysFromLowCal = obj => {
  if (typeof obj !== 'object') {
    return;
  }

  if (Array.isArray(obj)) {
    arrayConvertKeysFromLowCal(obj);
  } else {
    objectConvertKeysFromLowCal(obj);
  }
};

const setItem = (key, value) => {
  if (typeof key !== 'string' && typeof key !== 'number') {
    throw new TypeError('Provided key was not valid. Key: ' + key);
  }

  if (typeof value === 'object') {
    const valueClone = cloneObject(value);
    convertKeysToLowCal(valueClone);
    localStorage.setItem(key, JSON.stringify(valueClone));
  } else {
    localStorage.setItem(key, JSON.stringify(value));
  }
};

const getItem = key => {
  if (typeof key !== 'string' && typeof key !== 'number') {
    throw new TypeError('Provided key was not a string. Key: ' + key);
  }

  const value = JSON.parse(localStorage.getItem(key));
  convertKeysFromLowCal(value);
  return value;
};

const clear = () => {
  localStorage.clear();
};

const LowCalStorage = { getItem, setItem, clear };

/* harmony default export */ __webpack_exports__["default"] = (LowCalStorage);
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(1)(module)))

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if(!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true,
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ })
/******/ ]);
});
//# sourceMappingURL=LowCalStorage.min.js.map